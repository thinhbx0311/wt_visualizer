<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - glTF 2.0 - transmission</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			- GLTFLoader +
			<a
				href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen"
				target="_blank"
				rel="noopener"
				>KHR_materials_sheen</a
			>
			extension<br />
			Sheen Chair from
			<a
				href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/SheenChair"
				target="_blank"
				rel="noopener"
				>glTF-Sample-Models</a
			>
		</div>

		<script type="module">
			import * as THREE from "../build/three.module.js";

			import Stats from './jsm/libs/stats.module.js';
			import { OrbitControls } from "./jsm/controls/OrbitControls.js";
			import { GLTFLoader } from "./jsm/loaders/GLTFLoader.js";
			import { RoomEnvironment } from "./jsm/environments/RoomEnvironment.js";

			import { GUI } from "./jsm/libs/lil-gui.module.min.js";

			let camera, scene, renderer, controls, mixer, stats;
			let panelSettings, numAnimations;

			const allActions = [];
			const baseActions = {
				Action1: { weight: 1 },
				Action2: { weight: 0 },
				Action3: { weight: 0 },
			};
			const crossFadeControls = [];
			let currentBaseAction = "Action1";

			init();
			animate();

			function init() {
				const container = document.createElement("div");
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera(
					45,
					window.innerWidth / window.innerHeight,
					0.1,
					20
				);
				camera.position.set(0, 1, 2);

				scene = new THREE.Scene();

				// model

				new GLTFLoader().setPath("models/gltf/").load(
					"NU-SC180B_Anim.glb",
					function (gltf) {
						const model = gltf.scene;
						 scene.add(model);
						// var mixer = new THREE.AnimationMixer(model);
						// console.log(gltf.animations);
						// mixer.clipAction(gltf.animations[1]).play();

						// animate();

						//const object = gltf.scene.getObjectByName( 'SheenChair_fabric' );

						//	const gui = new GUI();

						//	gui.add( object.material, 'sheen', 0, 1 );
						//gui.open();

						const animations = gltf.animations;
						mixer = new THREE.AnimationMixer(model);

						numAnimations = animations.length;

						for (let i = 0; i !== numAnimations; ++i) {
							let clip = animations[i];
							const name = clip.name;
console.log(name);
							if (baseActions[name]) {
								const action = mixer.clipAction(clip);
								activateAction(action);
								baseActions[name].action = action;
								allActions.push(action);
							}
						}

						createPanel();

						animate();
					},
					undefined,
					function (e) {
						console.error(e);
					}
				);

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				container.appendChild(renderer.domElement);

				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator(renderer);

				scene.background = new THREE.Color(0xbbbbbb);
				scene.environment = pmremGenerator.fromScene(environment).texture;

				controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.minDistance = 1;
				controls.maxDistance = 10;
				controls.target.set(0, 0.5, 0);
				controls.update();

				window.addEventListener("resize", onWindowResize);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			//

			function animate() {
				// Render loop

				requestAnimationFrame( animate );

				

				// Get the time elapsed since the last frame, used for mixer update

				//const mixerUpdateDelta = clock.getDelta();

				// Update the animation mixer, the stats panel, and render this frame

				//mixer.update( mixerUpdateDelta );

			//	stats.update();

				renderer.render( scene, camera );
			}

			function render() {
				renderer.render(scene, camera);
			}

			function createPanel() {
				const panel = new GUI({ width: 310 });

				const folder1 = panel.addFolder("Base Actions");

				panelSettings = {
					"modify time scale": 1.0,
				};

				const baseNames = ["None", ...Object.keys(baseActions)];

				for (let i = 0, l = baseNames.length; i !== l; ++i) {
					const name = baseNames[i];
					const settings = baseActions[name];
					panelSettings[name] = function () {
						const currentSettings = baseActions[currentBaseAction];
						const currentAction = currentSettings
							? currentSettings.action
							: null;
						const action = settings ? settings.action : null;

						prepareCrossFade(currentAction, action, 0.35);
					};

					crossFadeControls.push(folder1.add(panelSettings, name));
				}

				crossFadeControls.forEach(function (control) {
					control.setInactive = function () {
						control.domElement.classList.add("control-inactive");
					};

					control.setActive = function () {
						control.domElement.classList.remove("control-inactive");
					};

					const settings = baseActions[control.property];

					if (!settings || !settings.weight) {
						control.setInactive();
					}
				});
			}
			function prepareCrossFade(startAction, endAction, duration) {
				// If the current action is 'idle', execute the crossfade immediately;
				// else wait until the current action has finished its current loop

				if (currentBaseAction === "idle" || !startAction || !endAction) {
					executeCrossFade(startAction, endAction, duration);
				} else {
					synchronizeCrossFade(startAction, endAction, duration);
				}

				// Update control colors

				if (endAction) {
					const clip = endAction.getClip();
					currentBaseAction = clip.name;
				} else {
					currentBaseAction = "None";
				}

				crossFadeControls.forEach(function (control) {
					const name = control.property;

					if (name === currentBaseAction) {
						control.setActive();
					} else {
						control.setInactive();
					}
				});
			}
			function synchronizeCrossFade(startAction, endAction, duration) {
				mixer.addEventListener("loop", onLoopFinished);

				function onLoopFinished(event) {
					if (event.action === startAction) {
						mixer.removeEventListener("loop", onLoopFinished);

						executeCrossFade(startAction, endAction, duration);
					}
				}
			}

			function executeCrossFade(startAction, endAction, duration) {
				// Not only the start action, but also the end action must get a weight of 1 before fading
				// (concerning the start action this is already guaranteed in this place)

				if (endAction) {
					setWeight(endAction, 1);
					endAction.time = 0;

					if (startAction) {
						// Crossfade with warping

						startAction.crossFadeTo(endAction, duration, true);
					} else {
						// Fade in

						endAction.fadeIn(duration);
					}
				} else {
					// Fade out

					startAction.fadeOut(duration);
				}
			}
		</script>
	</body>
</html>
